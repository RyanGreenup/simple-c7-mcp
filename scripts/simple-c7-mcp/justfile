package_name := `python -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['name'])"`

# Run the CLI without installing
run *args:
    uv run c7-mcp {{ args }}

lint:
    ruff check
    uv run -- pyright .
    uv run -- basedpyright .

format:
    ruff check --fix
    ruff format

test:
    pytest -v tests

# Run integration tests against a live server (requires: just serve)
test-integration port="8000":
    uv run python tests/test_integration.py --base-url http://localhost:{{ port }}

# Run MCP Streamable HTTP transport tests against a live server (requires: just serve)
test-mcp port="8000":
    uv run --group dev -- python -m pytest tests/test_mcp_transport.py -v --base-url http://localhost:{{ port }}

# Run integration tests including outbound URL-fetch tests (may be slow / rate-limited)
test-integration-full port="8000":
    uv run python tests/test_integration.py --base-url http://localhost:{{ port }} --include-fetch

# Start the FastAPI server in development mode (localhost + auto-reload)
serve port="8000":
    uv run c7-mcp serve --host 127.0.0.1 --port {{ port }} --reload

# Explicit development server alias
serve-dev port="8000":
    uv run c7-mcp serve --host 127.0.0.1 --port {{ port }} --reload

# Start a production-oriented server (bind all interfaces, no reload, configurable workers)
serve-prod host="0.0.0.0" port="8000" workers="4":
    uv run c7-mcp serve --host {{ host }} --port {{ port }} --workers {{ workers }}

# Check the health endpoint
health port="8000":
    curl -s http://127.0.0.1:{{ port }}/health | python -m json.tool

# Install the CLI tool globally
install:
    uv tool install . --force

# Uninstall the CLI tool
uninstall:
    uv tool uninstall {{ package_name }}

# Reinstall the CLI tool
reinstall:
    uv tool install . --force --reinstall

# ============================================================================
# Library Management
# ============================================================================

# Create a library
create-library name language ecosystem description="" port="8000":
    #!/usr/bin/env python3
    import json
    import urllib.request
    import sys

    url = "http://127.0.0.1:{{ port }}/api/v1/libraries"
    data = {
        "name": "{{ name }}",
        "language": "{{ language }}",
        "ecosystem": "{{ ecosystem }}",
        "description": "{{ description }}"
    }

    req = urllib.request.Request(
        url,
        data=json.dumps(data).encode('utf-8'),
        headers={'Content-Type': 'application/json'}
    )

    try:
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            print(json.dumps(result, indent=2))
            print(f"\n‚úÖ Created library: {result['name']}")
            print(f"   ID: {result['id']}")
            print(f"   Context7 ID: {result['context7_id']}")
    except urllib.error.HTTPError as e:
        error = json.loads(e.read().decode('utf-8'))
        print(f"‚ùå Error {e.code}: {error['detail']}")
        sys.exit(1)

# List all libraries
list-libraries port="8000":
    curl -s http://127.0.0.1:{{ port }}/api/v1/libraries | python -m json.tool

# Get a library by ID
get-library library_id port="8000":
    curl -s http://127.0.0.1:{{ port }}/api/v1/libraries/{{ library_id }} | python -m json.tool

# ============================================================================
# Document Management
# ============================================================================

# Get a document by ID (metadata only)
get-document doc_id port="8000":
    curl -s http://127.0.0.1:{{ port }}/api/v1/documents/{{ doc_id }} | python -m json.tool

# Get raw document content by ID
get-content doc_id port="8000":
    curl -s http://127.0.0.1:{{ port }}/api/v1/documents/{{ doc_id }}/content | python -m json.tool

# Test items 1-3: get-library, get-document, get-document-content
test-retrieval library_id doc_id port="8000":
    #!/usr/bin/env bash
    BASE="http://127.0.0.1:{{ port }}"
    echo "=== GET /api/v1/libraries/{{ library_id }} ==="
    curl -sf "$BASE/api/v1/libraries/{{ library_id }}" | jq .
    echo ""
    echo "=== GET /api/v1/documents/{{ doc_id }} ==="
    curl -sf "$BASE/api/v1/documents/{{ doc_id }}" | jq .
    echo ""
    echo "=== GET /api/v1/documents/{{ doc_id }}/content ==="
    curl -sf "$BASE/api/v1/documents/{{ doc_id }}/content" | jq .

# MCP: Resolve a library name to a Context7 ID
mcp-resolve library_name query="" port="8000":
    #!/usr/bin/env python3
    import json
    import urllib.request
    import sys

    url = "http://127.0.0.1:{{ port }}/mcp"
    data = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
            "name": "resolve-library-id",
            "arguments": {
                "libraryName": "{{ library_name }}",
                "query": "{{ query }}"
            }
        }
    }

    req = urllib.request.Request(
        url,
        data=json.dumps(data).encode('utf-8'),
        headers={'Content-Type': 'application/json'}
    )

    try:
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            print(result['result']['content'][0]['text'])
    except urllib.error.HTTPError as e:
        error = json.loads(e.read().decode('utf-8'))
        print(f"Error {e.code}: {error['detail']}")
        sys.exit(1)

# MCP: Query docs for a library (use context7_id from mcp-resolve)
mcp-query library_id query port="8000":
    #!/usr/bin/env python3
    import json
    import urllib.request
    import sys

    url = "http://127.0.0.1:{{ port }}/mcp"
    data = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
            "name": "query-docs",
            "arguments": {
                "libraryId": "{{ library_id }}",
                "query": "{{ query }}"
            }
        }
    }

    req = urllib.request.Request(
        url,
        data=json.dumps(data).encode('utf-8'),
        headers={'Content-Type': 'application/json'}
    )

    try:
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            print(result['result']['content'][0]['text'])
    except urllib.error.HTTPError as e:
        error = json.loads(e.read().decode('utf-8'))
        print(f"Error {e.code}: {error['detail']}")
        sys.exit(1)

# Upload a document from a file
upload-doc file library_id title="" port="8000":
    #!/usr/bin/env python3
    import json
    import urllib.request
    import sys
    from pathlib import Path

    file_path = Path("{{ file }}")
    if not file_path.exists():
        print(f"‚ùå File not found: {file_path}")
        sys.exit(1)

    content = file_path.read_text(encoding='utf-8')
    title = "{{ title }}" or file_path.stem

    url = "http://127.0.0.1:{{ port }}/api/v1/documents"
    data = {
        "title": title,
        "library_id": "{{ library_id }}",
        "content": content
    }

    print(f"üì§ Uploading: {file_path.name}")
    print(f"   Title: {title}")
    print(f"   Library: {{ library_id }}")
    print(f"   Size: {len(content)} bytes")
    print()

    req = urllib.request.Request(
        url,
        data=json.dumps(data).encode('utf-8'),
        headers={'Content-Type': 'application/json'}
    )

    try:
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            print("‚úÖ Document uploaded successfully!")
            print(f"   ID: {result['id']}")
            print(f"   Title: {result['title']}")
    except urllib.error.HTTPError as e:
        error = json.loads(e.read().decode('utf-8'))
        print(f"‚ùå Error {e.code}: {error['detail']}")
        sys.exit(1)

# Fetch documentation from Context7 and upload to our API
fetch-doc library query port="8000":
    #!/usr/bin/env python3
    import json
    import sys
    import os
    import urllib.request
    from pathlib import Path

    library = "{{ library }}"
    query = "{{ query }}"
    api_port = "{{ port }}"

    if not query:
        print("‚ùå Error: query parameter is required")
        print()
        print("Usage: just fetch-doc LIBRARY 'your question or use case'")
        print()
        print("Examples:")
        print("  just fetch-doc 'solidstart' 'How to throw a redirect in SolidStart'")
        print("  just fetch-doc 'fastapi' 'How to create a REST API with authentication'")
        print("  just fetch-doc 'react' 'useState hook documentation'")
        print()
        print("The query helps Context7 find the most relevant library match")
        print("and improves documentation quality.")
        sys.exit(1)

    print(f"üîç Step 1: Resolving library: {library}")
    print(f"   Query context: {query}")
    print()

    # Step 1: Call Context7 MCP API to resolve library name
    mcp_url = "https://mcp.context7.com/mcp"
    api_key = os.environ.get('CONTEXT7_API_KEY', '')

    request_data = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
            "name": "resolve-library-id",
            "arguments": {
                "libraryName": library,
                "query": query
            }
        }
    }

    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json, text/event-stream'
    }
    if api_key:
        headers['CONTEXT7_API_KEY'] = api_key

    req = urllib.request.Request(
        mcp_url,
        data=json.dumps(request_data).encode('utf-8'),
        headers=headers
    )

    try:
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
    except Exception as e:
        print(f"‚ùå Context7 API request failed: {e}")
        sys.exit(1)

    # Parse the response to get library_id
    try:
        content_text = result['result']['content'][0]['text']

        # Parse library options
        libraries = []
        current_lib = {}

        for line in content_text.split('\n'):
            line = line.strip()

            if line.startswith('- Title:'):
                if current_lib.get('id'):
                    libraries.append(current_lib)
                current_lib = {'title': line.split('- Title:')[1].strip()}
            elif line.startswith('- Context7-compatible library ID:'):
                current_lib['id'] = line.split('Context7-compatible library ID:')[1].strip()
            elif line.startswith('- Description:'):
                current_lib['description'] = line.split('- Description:')[1].strip()
            elif line.startswith('- Benchmark Score:'):
                try:
                    current_lib['score'] = float(line.split('- Benchmark Score:')[1].strip())
                except:
                    current_lib['score'] = 0

        if current_lib.get('id'):
            libraries.append(current_lib)

        if not libraries:
            print("‚ùå No libraries found in Context7 response")
            sys.exit(1)

        # Pick best match
        libraries.sort(key=lambda x: x.get('score', 0), reverse=True)
        best_match = libraries[0]
        library_id = best_match['id']

        print(f"‚úÖ Resolved: {best_match['title']}")
        print(f"   Context7 ID: {library_id}")
        print(f"   Score: {best_match.get('score', 'N/A')}")

    except (KeyError, IndexError, TypeError) as e:
        print(f"‚ùå Failed to parse Context7 response: {e}")
        sys.exit(1)

    # Step 2: Download documentation
    print(f"\nüì• Step 2: Downloading documentation...")
    doc_url = f"https://context7.com{library_id}/llms.txt"
    print(f"   URL: {doc_url}")

    try:
        with urllib.request.urlopen(doc_url) as response:
            content = response.read().decode('utf-8')
        print(f"‚úÖ Downloaded: {len(content)} bytes")
    except Exception as e:
        print(f"‚ùå Failed to download: {e}")
        sys.exit(1)

    # Step 3: Create library in our API (if not exists)
    print(f"\nüìö Step 3: Creating library in our API...")

    # Extract language and ecosystem from library_id
    # Format: /npm/package-name or /pypi/package-name or /github/org/repo
    parts = library_id.strip('/').split('/')
    if len(parts) >= 2:
        ecosystem = parts[0]
        # Map ecosystems to languages
        language_map = {
            'npm': 'JavaScript',
            'pypi': 'Python',
            'github': 'Unknown',
            'websites': 'Unknown',
            'go': 'Go',
            'crates': 'Rust',
        }
        language = language_map.get(ecosystem, 'Unknown')
    else:
        ecosystem = 'unknown'
        language = 'Unknown'

    lib_api_url = f"http://127.0.0.1:{api_port}/api/v1/libraries"
    lib_data = {
        "name": library,
        "language": language,
        "ecosystem": ecosystem,
        "context7_id": library_id,
        "description": best_match.get('description', '')
    }

    req = urllib.request.Request(
        lib_api_url,
        data=json.dumps(lib_data).encode('utf-8'),
        headers={'Content-Type': 'application/json'}
    )

    try:
        with urllib.request.urlopen(req) as response:
            lib_result = json.loads(response.read().decode('utf-8'))
            our_library_id = lib_result['id']
            print(f"‚úÖ Library created: {lib_result['name']}")
            print(f"   ID: {our_library_id}")
    except urllib.error.HTTPError as e:
        if e.code == 400:
            # Library already exists, that's OK
            error = json.loads(e.read().decode('utf-8'))
            if 'already exists' in error['detail']:
                print(f"‚ÑπÔ∏è  Library already exists, querying for ID...")
                # Query the libraries endpoint to find the existing library
                list_req = urllib.request.Request(lib_api_url)
                try:
                    with urllib.request.urlopen(list_req) as list_response:
                        all_libs = json.loads(list_response.read().decode('utf-8'))
                        # Find library by name and ecosystem
                        matching_lib = None
                        for lib in all_libs:
                            if lib['name'].lower() == library.lower() and lib['ecosystem'] == ecosystem:
                                matching_lib = lib
                                break

                        if matching_lib:
                            our_library_id = matching_lib['id']
                            print(f"‚úÖ Found existing library: {matching_lib['name']}")
                            print(f"   ID: {our_library_id}")
                        else:
                            print(f"‚ùå Library exists but couldn't find it in the list")
                            sys.exit(1)
                except Exception as query_error:
                    print(f"‚ùå Failed to query libraries: {query_error}")
                    sys.exit(1)
            else:
                print(f"‚ùå Error: {error['detail']}")
                sys.exit(1)
        else:
            print(f"‚ùå Error {e.code}")
            sys.exit(1)

    # Step 4: Upload document to our API
    print(f"\nüì§ Step 4: Uploading document to our API...")
    doc_api_url = f"http://127.0.0.1:{api_port}/api/v1/documents"
    doc_data = {
        "title": f"{library} Documentation",
        "library_id": our_library_id,
        "content": content
    }

    req = urllib.request.Request(
        doc_api_url,
        data=json.dumps(doc_data).encode('utf-8'),
        headers={'Content-Type': 'application/json'}
    )

    try:
        with urllib.request.urlopen(req) as response:
            doc_result = json.loads(response.read().decode('utf-8'))
            print(f"‚úÖ Document uploaded!")
            print(f"   ID: {doc_result['id']}")
            print(f"   Title: {doc_result['title']}")
    except urllib.error.HTTPError as e:
        error = json.loads(e.read().decode('utf-8'))
        print(f"‚ùå Error {e.code}: {error['detail']}")
        sys.exit(1)

    print(f"\nüéâ Complete! {library} documentation is now in the system")
    print(f"   Library ID: {our_library_id}")
    print(f"   Context7 ID: {library_id}")

# ============================================================================
# Demo Commands
# ============================================================================

# Demo: Create library and upload a document
demo port="8000":
    @echo "üöÄ Running complete demo..."
    @echo ""
    @echo "Step 1: Starting server (if not running)"
    @echo "  Run 'just serve' in another terminal first!"
    @echo ""
    @echo "Step 2: Creating FastAPI library"
    just create-library "FastAPI" "Python" "pypi" "Modern Python web framework" {{ port }}
    @echo ""
    @echo "Step 3: Creating a sample document file"
    @mkdir -p tests/data
    @echo "# FastAPI Quick Start\n\nFastAPI is a modern web framework for building APIs." > tests/data/fastapi-sample.md
    @echo ""
    @echo "Step 4: Uploading document"
    just upload-doc tests/data/fastapi-sample.md "lib-pypi-fastapi-*" "FastAPI Quick Start" {{ port }}
    @echo ""
    @echo "‚úÖ Demo complete!"

# Demo: Fetch library from Context7
demo-fetch library="solidstart" query="How to throw a redirect in SolidStart" port="8000":
    @echo "üöÄ Fetching {{ library }} from Context7..."
    @echo ""
    just fetch-doc "{{ library }}" "{{ query }}" {{ port }}
    @echo ""
    @echo "‚úÖ Demo complete!"

# Quick fetch with common use cases (queries include library name for better context)
fetch-solidstart port="8000":
    just fetch-doc "solidstart" "How to throw a redirect in SolidStart" {{ port }}

fetch-fastapi port="8000":
    just fetch-doc "fastapi" "How to create a REST API with authentication using FastAPI" {{ port }}

fetch-react port="8000":
    just fetch-doc "react" "How to use useState and useEffect hooks in React" {{ port }}

fetch-vue port="8000":
    just fetch-doc "vue" "Vue 3 Composition API and reactive state management" {{ port }}

fetch-vue-router port="8000":
    just fetch-doc "vue-router" "How to define and configure API routes in Vue Router" {{ port }}

fetch-daisyui port="8000":
    just fetch-doc "daisyui" "How to use button and card components in DaisyUI" {{ port }}

# ============================================================================
# Collection Seeding Commands
# ============================================================================

# Seed the document collection with the default required libraries.
seed-docs port="8000":
    just seed-docs-group "required" "" {{ port }}

# Seed a library group by fetching docs from Context7 and uploading to this server.
seed-docs-group group="required" query="" port="8000":
    #!/usr/bin/env python3
    import subprocess
    import sys

    target_group = "{{ group }}"
    query_override = "{{ query }}".strip()
    api_port = "{{ port }}"

    groups = {
        "required": [
            "solidstart",
            "fastapi",
            "react",
            "vue",
            "vue-router",
            "daisyui",
            "clickhouse",
            "lancedb",
        ],
        "frontend": [
            "solidstart",
            "react",
            "vue",
            "vue-router",
            "daisyui",
        ],
        "backend": [
            "fastapi",
            "pydantic",
            "typer",
        ],
        "data": [
            "clickhouse",
            "duckdb",
            "lancedb",
            "pgvector",
        ],
    }

    library_queries = {
        "solidstart": "How to throw a redirect in SolidStart",
        "fastapi": "How to create a REST API with authentication using FastAPI",
        "react": "How to use useState and useEffect hooks in React",
        "vue": "Vue 3 Composition API and reactive state management",
        "vue-router": "How to define and configure routes in Vue Router",
        "daisyui": "How to use button and card components in DaisyUI",
        "clickhouse": "ClickHouse SQL reference and table engine documentation",
        "duckdb": "DuckDB SQL analytics with local files and parquet datasets",
        "lancedb": "LanceDB vector search and document embedding workflows",
        "pgvector": "pgvector extension for vector similarity in PostgreSQL",
        "pydantic": "Pydantic model validation and settings management",
        "typer": "Typer CLI commands, arguments, and options",
    }

    if target_group == "all":
        seen = set()
        libraries = []
        for libs in groups.values():
            for library in libs:
                if library not in seen:
                    seen.add(library)
                    libraries.append(library)
    else:
        libraries = groups.get(target_group)
        if libraries is None:
            print(f"‚ùå Unknown group: {target_group}")
            print("Valid groups: required, frontend, backend, data, all")
            sys.exit(1)

    print(f"üå± Seeding group '{target_group}' into server on port {api_port}")
    print(f"üìö Libraries: {len(libraries)}")
    print()

    success = []
    failed = []

    for i, library in enumerate(libraries, 1):
        query = query_override or library_queries.get(
            library, f"{library} official documentation API reference"
        )
        print(f"[{i}/{len(libraries)}] Fetching {library}")
        print(f"    Query: {query}")
        try:
            result = subprocess.run(
                ["just", "fetch-doc", library, query, api_port],
                timeout=240,
            )
            if result.returncode == 0:
                success.append(library)
            else:
                failed.append(library)
        except subprocess.TimeoutExpired:
            print("    ‚ùå Timed out")
            failed.append(library)
        except Exception as exc:
            print(f"    ‚ùå Error: {exc}")
            failed.append(library)
        print()

    print("üìä Seed summary")
    print(f"   ‚úÖ Success: {len(success)}")
    print(f"   ‚ùå Failed: {len(failed)}")

    if failed:
        print("   Failed libraries:")
        for library in failed:
            print(f"   - {library}")

    sys.exit(0 if not failed else 1)

# ============================================================================
# Database Inspection Commands
# ============================================================================

# Open a DuckDB SQL shell with LanceDB data loaded
sql table="libraries" db_path="./lancedb_data":
    #!/usr/bin/env python3
    import sys
    import subprocess
    from pathlib import Path

    db_path = "{{ db_path }}"
    table = "{{ table }}"

    if not Path(db_path).exists():
        print(f"‚ö†Ô∏è  Database not found at: {db_path}")
        print("Run 'just serve' first to initialize the database")
        sys.exit(1)

    print("ü¶Ü Opening DuckDB SQL shell with LanceDB data...")
    print(f"üìä Database: {db_path}")
    print(f"üìã Table: {table}")
    print()
    print("Available tables:")
    print("  - libraries (library metadata)")
    print("  - documents (document chunks with embeddings)")
    print()
    print("Example queries:")
    print("  SELECT COUNT(*) FROM data;")
    print("  SELECT name, ecosystem, document_count FROM data LIMIT 10;")
    if table == "documents":
        print("  SELECT title, library_name, chunk_index FROM data LIMIT 10;")
    print("  .schema data")
    print()

    # Build Lance scan path
    view_path = f"{db_path}/{table}.lance"

    if not Path(view_path).exists():
        print(f"‚ùå Table '{table}' not found at: {view_path}")
        print(f"Available tables: libraries, documents")
        sys.exit(1)

    # Build init commands
    commands = []
    commands.append("INSTALL lance FROM community;")
    commands.append("LOAD lance;")
    commands.append(f"CREATE OR REPLACE VIEW data AS SELECT * FROM __lance_scan('{view_path}');")
    commands.append(".timer on")
    commands.append("SELECT 'üéØ Connected! Table \"data\" has ' || COUNT(*)::VARCHAR || ' rows' as status FROM data;")
    init_script = "\n".join(commands)

    # Build the bash command with heredoc
    bash_cmd = f"duckdb -init <(cat <<'INITEOF'\n{init_script}\nINITEOF\n)"

    subprocess.run(['bash', '-c', bash_cmd])

# Open SQL shell for documents table
sql-docs db_path="./lancedb_data":
    just sql "documents" {{ db_path }}

# Clean the database (WARNING: deletes all data)
clean-db:
    rm -rf lancedb_data
    @echo "‚úÖ Database cleaned"
    @echo "‚ö†Ô∏è  Run 'just serve' to reinitialize"
